/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate } from "workbox-strategies"

// Import Firebase for messaging
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope

// Import Firebase scripts
importScripts("https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js")
importScripts(
    "https://www.gstatic.com/firebasejs/9.0.0/firebase-messaging-compat.js"
)

// Initialize Firebase
// @ts-ignore
firebase.initializeApp({
    apiKey: "AIzaSyBPQk8DKDZvO88IL5War-0k-GLFmCvqeIg",
    authDomain: "hcnxsryjficudzazjxty.firebaseapp.com",
    projectId: "hcnxsryjficudzazjxty",
    storageBucket: "hcnxsryjficudzazjxty.firebasestorage.app",
    messagingSenderId: "808002047047",
    appId: "1:808002047047:web:251d7d87c213ffd1233562",
    measurementId: "G-L54PGXRRZV",
})

// Get Firebase messaging instance
// @ts-ignore
const messaging = firebase.messaging()

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$")
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== "navigate") {
            return false
        }

        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith("/_")) {
            return false
        }

        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (url.pathname.match(fileExtensionRegexp)) {
            return false
        }

        // Return true to signal that we want to use the handler.
        return true
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
    // Add in any other file extensions or routing criteria as needed.
    ({ url }) =>
        url.origin === self.location.origin && url.pathname.endsWith(".png"),
    // Customize this strategy as needed, e.g., by changing to CacheFirst.
    new StaleWhileRevalidate({
        cacheName: "images",
        plugins: [
            // Ensure that once this runtime cache reaches a maximum size the
            // least-recently used images are removed.
            new ExpirationPlugin({ maxEntries: 50 }),
        ],
    })
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
        // Force skipWaiting and claim clients immediately
        self.skipWaiting().then(() => {
            // Claim all clients to ensure immediate control
            return self.clients.claim()
        })
    }
})

// Handle activation to ensure proper cleanup of old caches
self.addEventListener("activate", (event) => {
    // Take control of all clients immediately
    event.waitUntil(self.clients.claim())
})

// Firebase messaging - handle background messages
messaging.onBackgroundMessage(function (payload) {
    console.log("[service-worker] Received background message ", payload)

    // Check if any client (browser tab) is currently focused
    return self.clients
        .matchAll({ type: "window" })
        .then(function (clientList) {
            let isAppInForeground = false

            console.log("[service-worker] Found clients:", clientList.length)

            for (let i = 0; i < clientList.length; i++) {
                console.log(
                    "[service-worker] Client",
                    i,
                    "focused:",
                    clientList[i].focused,
                    "url:",
                    clientList[i].url
                )
                if (clientList[i].focused) {
                    isAppInForeground = true
                    break
                }
            }

            console.log(
                "[service-worker] App in foreground:",
                isAppInForeground
            )

            // Only show notification if app is NOT in foreground
            if (!isAppInForeground) {
                console.log("[service-worker] Showing background notification")

                const notificationTitle =
                    payload.notification?.title ||
                    payload.data?.title ||
                    "DDO Audit"
                const notificationBody =
                    payload.notification?.body ||
                    payload.data?.body ||
                    "New notification"

                const notificationOptions = {
                    body: "THIS BODY IS FROM service-worker.ts", //notificationBody,
                    icon: "/icons/logo-192px.png",
                    badge: "/icons/logo-192px.png",
                    tag: "ddo-notification",
                    data: payload.data || {},
                    requireInteraction: true,
                    actions: [
                        {
                            action: "open",
                            title: "Open App",
                        },
                        {
                            action: "dismiss",
                            title: "Dismiss",
                        },
                    ],
                }

                return self.registration.showNotification(
                    "notificationTitle from service-worker.ts",
                    notificationOptions
                )
            } else {
                console.log(
                    "[service-worker] App is in foreground, not showing notification"
                )
            }
        })
})

// Handle notification click
self.addEventListener("notificationclick", function (event) {
    console.log("[service-worker] Notification click received.")

    event.notification.close()

    if (event.action === "open" || !event.action) {
        // Open the app
        event.waitUntil(
            self.clients
                .matchAll({ type: "window", includeUncontrolled: true })
                .then(function (clientList) {
                    // If the app is already open, focus it
                    for (let i = 0; i < clientList.length; i++) {
                        const client = clientList[i]
                        if (
                            client.url.includes(self.location.origin) &&
                            "focus" in client
                        ) {
                            return client.focus()
                        }
                    }
                    // If the app is not open, open it
                    if (self.clients.openWindow) {
                        return self.clients.openWindow("/")
                    }
                })
        )
    }
    // Dismiss action just closes the notification (already done above)
})

// Any other custom service worker logic can go here.
